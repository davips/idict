![test](https://github.com/davips/idict/workflows/test/badge.svg)
[![codecov](https://codecov.io/gh/davips/idict/branch/main/graph/badge.svg)](https://codecov.io/gh/davips/idict)
<a href="https://pypi.org/project/idict">
<img src="https://img.shields.io/pypi/v/idict.svg?label=release&color=blue&style=flat-square" alt="pypi">
</a>
![Python version](https://img.shields.io/badge/python-3.8%20%7C%203.9-blue.svg)
[![license: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)

<!--- [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.5501845.svg)](https://doi.org/10.5281/zenodo.5501845) --->
[![arXiv](https://img.shields.io/badge/arXiv-2109.06028-b31b1b.svg?style=flat-square)](https://arxiv.org/abs/2109.06028)
[![API documentation](https://img.shields.io/badge/doc-API%20%28auto%29-a0a0a0.svg)](https://davips.github.io/idict)

# idict

A lazy `dict` with universally unique deterministic identifiers.

[Latest release](https://pypi.org/project/idict) |
[Current code](https://github.com/davips/idict) |
[API documentation](https://davips.github.io/idict)

## Overview

An `idict` is a `dict` with `str` keys.

## See also

* laziness+identity ([ldict](https://pypi.org/project/ldict))
* laziness+identity+persistence ([cdict](https://pypi.org/project/cdict))

We consider that every value is generated by a process, starting from an `empty` `idict`. The process is a sequence of
transformation steps done through the operator `>>`, which symbolizes the ordering of the steps.
There are two types of steps:

* **value insertion** - represented by dict-like objects
* **function application** - represented by ordinary Python functions

Functions, `idict`s, and values have a deterministic UUID
(called _hosh_ - **o**perable **h**a**sh**). 
Identifiers (hoshes) for `idict`s and values are predictable through the
magic available [here](https://pypi.org/project/garoupa).
An `idict` is completely defined by its key-value pairs so that
it can be converted from/to a built-in `dict`.

Creating an `idict` is not different from creating an ordinary `dict`. Optionally it can be created through the `>>` operator
used after `empty` or `Ø` (usually AltGr+Shift+o in most keyboards).
The resulting `idict` always contains two extra entries `id` and `ids`:
![img.png](https://raw.githubusercontent.com/davips/idict/main/examples/img.png)

Function application is done in the same way. The parameter names define the input fields, while the keys in the
returned `dict` define the output fields:
![img_1.png](https://raw.githubusercontent.com/davips/idict/main/examples/img_1.png)

After evaluated, the value will not be calculated again:
![img_2.png](https://raw.githubusercontent.com/davips/idict/main/examples/img_2.png)

Functions can accept parameters:
![img_3.png](https://raw.githubusercontent.com/davips/idict/main/examples/img_3.png)


## Installation
### ...as a standalone lib
```bash
# Set up a virtualenv. 
python3 -m venv venv
source venv/bin/activate

# Install from PyPI...
pip install --upgrade pip
pip install -U idict

# ...or, install from updated source code.
pip install git+https://github.com/davips/idict
```

### ...from source
```bash
git clone https://github.com/davips/idict
cd idict
poetry install
```

## Examples
<<overview>>

<<levelid>>

<<merging>>

<<apply>>

<<sampling>>

<<compositionofsets>>

<!--- ## Persistence
Extra dependencies can be installed to support saving data to disk or to a server in the network. 

**[still an ongoing work...]**

`poetry install -E full`
--->

## Concept

An `idict` is like a common Python `dict`, with extra functionality and lazy. 
It is a mapping between string keys, called
fields, and any serializable (pickable) object.
Each `idict` has two extra entries: `id` (identifier) and `ids` (value identifiers).

The user can provide a 40-digit unique identifier (see [GaROUPa](https://pypi.org/project/garoupa))
for each function or value object. 
Otherwise, they will be calculated through blake3 hashing of the content of data or
bytecode of function. 
For this reason, such functions should be simple, i.e., with minimal external dependencies, to
avoid the unfortunate situation where two functions with identical local code actually perform different calculations
through calls to external code that implement different algorithms with the same name.

## Grants
This work was supported by Fapesp under supervision of
Prof. André C. P. L. F. de Carvalho at CEPID-CeMEAI (Grants 2013/07375-0 – 2019/01735-0)
until 2021-03-31.
